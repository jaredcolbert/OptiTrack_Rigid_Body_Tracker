import sys
import time
import threading
from NatNetClient import NatNetClient
try:
    import msvcrt  # Windows non-blocking keyboard input
    _HAS_MS = True
except Exception:
    _HAS_MS = False

SERVER_IP = "192.168.86.39"
TARGET_ID = 1
UNIT_SCALE = 1000.0  # meters -> millimeters


class _MapState:
    """Holds latest and reference positions for mapping computations."""
    def __init__(self):
        self.lock = threading.Lock()
        self.latest_rb_mm = None  # (x, y, z) in mm
        self.ref_rb_mm = None     # (x, y, z) in mm
        self.ref_mapped_mm = None # (x, y, z) in mm (user-provided)

    def set_latest(self, pos_mm):
        with self.lock:
            self.latest_rb_mm = pos_mm

    def set_reference(self, rb_mm, mapped_mm):
        with self.lock:
            self.ref_rb_mm = rb_mm
            self.ref_mapped_mm = mapped_mm

    def get_latest(self):
        with self.lock:
            return self.latest_rb_mm

    def get_prediction(self):
        with self.lock:
            if self.latest_rb_mm is None or self.ref_rb_mm is None or self.ref_mapped_mm is None:
                return None
            lx, ly, lz = self.latest_rb_mm
            rx, ry, rz = self.ref_rb_mm
            mx, my, mz = self.ref_mapped_mm
            # Assume same scale/orientation; apply pure translation based on RB delta
            return (mx + (lx - rx), my + (ly - ry), mz + (lz - rz))


_state = _MapState()


def on_rigid_body(rigid_body_id, position, rotation, *rest):
    try:
        if rigid_body_id != TARGET_ID:
            return
        # Optional tracking valid flag (bool/int) as first extra arg
        if rest and isinstance(rest[0], (bool, int)) and not bool(rest[0]):
            return

        x, y, z = position
        # rotation is expected (qw, qx, qy, qz)
        qw, qx, qy, qz = rotation
        # convert to mm
        x *= UNIT_SCALE
        y *= UNIT_SCALE
        z *= UNIT_SCALE
        # update latest position for mapping
        _state.set_latest((x, y, z))
        print(f"RB {rigid_body_id}: x={x:.3f} mm, y={y:.3f} mm, z={z:.3f} mm, qw={qw:.6f}, qx={qx:.6f}, qy={qy:.6f}, qz={qz:.6f}")
    except Exception:
        pass


def main():
    client = NatNetClient()
    client.set_use_multicast(False)
    try:
        client.set_print_level(0)
    except Exception:
        pass
    client.set_server_address(SERVER_IP)
    client.set_client_address(SERVER_IP)
    client.rigid_body_listener = on_rigid_body
    try:
        client.new_frame_listener = lambda *_a, **_k: None
        client.new_frame_with_data_listener = lambda *_a, **_k: None
    except Exception:
        pass

    if not client.run('d'):
        print("ERROR: Could not start streaming client.")
        try:
            sys.exit(1)
        except SystemExit:
            return

    time.sleep(1)
    if not client.connected():
        print("ERROR: Could not connect properly. Check Motive streaming and IP settings.")
        try:
            sys.exit(2)
        except SystemExit:
            return

    print(f"Connected to NatNet server at {SERVER_IP} (Unicast). Printing RB {TARGET_ID} pose in mm...")
    print("Controls: [c] capture reference + enter mapped coords, [p] predict mapped at current pose, [r] reset, [q] quit")
    try:
        while True:
            # Poll keys (Windows). If not available, just sleep and rely on prints.
            if _HAS_MS and msvcrt.kbhit():
                key = msvcrt.getwch().lower()
                if key == 'q':
                    print("Quitting...")
                    break
                elif key == 'r':
                    _state.set_reference(None, None)
                    print("Mapping reset.")
                elif key == 'c':
                    cur = _state.get_latest()
                    if not cur:
                        print("No rigid body sample yet. Wait for data.")
                    else:
                        print(f"Captured reference RB at (mm) {cur}. Enter mapped coordinates in mm as 'x y z':")
                        try:
                            line = input().strip()
                            parts = [p for p in line.replace(',', ' ').split() if p]
                            if len(parts) != 3:
                                print("Invalid input. Expect three numbers: x y z")
                            else:
                                mx, my, mz = map(float, parts)
                                _state.set_reference(cur, (mx, my, mz))
                                print(f"Reference set. RB_ref(mm)={cur} -> Mapped_ref(mm)=({mx:.3f}, {my:.3f}, {mz:.3f})")
                        except Exception as e:
                            print(f"Input error: {e}")
                elif key == 'p':
                    pred = _state.get_prediction()
                    if pred is None:
                        print("Prediction unavailable. Press 'c' first to set reference and mapped coords.")
                    else:
                        px, py, pz = pred
                        print(f"Predicted mapped (mm): x={px:.3f}, y={py:.3f}, z={pz:.3f}")
            time.sleep(0.05)
    except KeyboardInterrupt:
        pass
    finally:
        try:
            client.shutdown()
        except Exception:
            pass


if __name__ == "__main__":
    main()

